---
title: "MFE R Programming Workshop"
author: "Brett Dunn and Mahyar Kargar"
date: "Fall 2017"
output:
  beamer_presentation:
    includes:
      in_header: ../slide_header.tex
    keep_tex: false
subtitle: Week 4
slide_level: 2
---
# Introduction

## Questions
\begin{center}
\Large Any questions before we start?
\end{center}

## Overview of Week 4
- Strings
- Dates
- Lab

# Strings

## Strings
- A string is a sequence of characters.
- In `R`, a sting falls in the `character` class.
```{r}
mystring <- "Hello"
str(mystring)
```
- Character vectors are created like numeric vectors.
```{r}
myvec <- c("Hello", "Goodbye")
str(myvec)
```

## Manipulating Strings
- `R` provides many functions to manipulate strings.
    - `grep()`: Searches for a substring, like the Linux command of the same name.
    - `gsub()`: Replaces all matches of a string with another string.
    - `nchar()`: Finds the length of a string.
    - `paste()` and `paste0()`: Assembles a string from parts.  
    - `sprintf()`: Assembles a string from parts.
    - `substr()`: Extracts a substring.
    - `strsplit()`: Splits a string into substrings.
- Hadley Wickham's `stringr` package provides additional functions for using regular expressions and examining text data.

## `grep()`
- The call `grep(pattern, x)` searches for a specified substring pattern in a vector `x` of strings.
- If `x` has `n` elements—that is, it contains `n` strings—then `grep(pattern, x)` will return a vector of length up to `n`.
- Each element of this vector will be the index in `x` at which a match of pattern as a substring of `x` was found.
```{r}
grep("Pole",c("Equator","North Pole","South Pole"))
```

## `gsub()`
- The call `gsub(pattern, replacement, x)` searches for a specified substring pattern in a vector `x` of strings and replaces it with the provided replacement string.
- If `x` has `n` elements, `gsub()` will return a string vector of length to `n`.
- If the substring is not found, it returns the original string.
```{r}
gsub(" Pole","",c("Equator","North Pole","South Pole"))
```


## `nchar()`
- The call `nchar(x)` finds the length of a string `x`.
```{r}
nchar("South Pole")
```

## `paste()`
- The call `paste(...)` concatenates several strings, returning the result in one
long string.
```{r}
paste("North","and","South","Poles")
paste("North","Pole",sep="")
# paste0 is same as sep="" (more efficient)
paste0("North","Pole") == paste("North","Pole",sep="") 
```

## `sprintf()`
- The call `sprintf(...)` assembles a string from parts in a formatted manner.
- Similar to the `C` function `printf`.
```{r}
i <- 8
sprintf("the square of %d is %d",i,i^2)
```

## `substr()`
- The call `substr(x,start,stop)` returns the substring in the given character position range `start:stop` in the given string `x`.
```{r}
substring("Equator",3,5)
```

## `strsplit()`
- The call `strsplit(x,split)` splits a string `x` into an `R` list of substrings based on another string `split` in `x`.
```{r}
strsplit("10-05-2017",split="-")
```

## Example: Creating File Names
- Suppose we want to create five files, `q1.pdf` through `q5.pdf`, consisting of
histograms of 100 random N(0,i2) variates. We could execute the following
code:
```{r, eval=FALSE}
for (i in 1:5) {
  fname <- paste("q",i,".pdf")
  pdf(fname)
  hist(rnorm(100,sd=i))
  dev.off()
}
```

# Dates


## Why do we need date/time classes?

\centerline{
  \includegraphics[width=\textwidth,height=0.85\textheight,keepaspectratio]{./railroad_time.jpg}
}


## Date Classes in R
- `Date` is in `yyyy-mm-dd` format and represents the number of days since Jamuary 1, 1970
- `POSIXct` represents the (signed) number of seconds since Jamuary 1, 1970 (in the UTC time zone) as a numeric vector.
- `POSIXlt` is a named list of vectors representing `sec`, `min`, `hour`, `mday`, `mon`, `year`, time zone par maters, and a few other items.
```{r}
x <- Sys.time()  # clock time as a POSIXct object
x; as.numeric(x)
```

## Creating Dates
- Typically, dates come into R as character strings.
- By default, R assumes the string is in the format `yyyy-mm-dd` or `yyyy-mm-dd`
```{r}
mychar <- "2017-10-05"
mydate <- as.Date(mychar)
str(mydate)
```

## Date Formats
- `R` can parse many other types of date formats.
- See `?strptime` for details.
```{r}
mychar <- "October 5th, 2017"
mydate <- as.Date(mychar, format = "%B %eth, %Y")
str(mydate)
```

## Extract Parts of a Date Object
```{r}
mydate <- as.Date("2017-10-05")
weekdays(mydate)
months(mydate)
quarters(mydate)
```

## Generate Regular Sequences of Dates
```{r, tidy=TRUE, size = "footnotesize"}
## first days of years
seq(as.Date("2007/1/1"), as.Date("2010/1/1"), "years")
## by month
seq(as.Date("2000/1/1"), by = "month", length.out = 4)
## quarters
seq(as.Date("2000/1/1"), as.Date("2001/1/1"), 
    by = "quarter")
```

## Time Intervals / Differences
- Function difftime calculates a difference of two date/time objects and returns an object of class "difftime" with an attribute indicating the units.
```{r}
time1 <- as.Date("2017-10-05")
time2 <- as.Date("2008-07-08")
time1 - time2
difftime(time1, time2, units = "weeks")
```


## Dates in Microsoft Excel
- Microsoft Excel stores dates as the number of days since Decemeber 31, 1899.
- However, Excel also incorrectly assumes that the year 1900 is a leap year to allow for compatability with Lotus 1-2-3.
- Therefore, for dates after 1901, set the origin to Decemeber 30, 1899 to convert an Excel date to an R date.
```{r}
as.Date(43013, origin = "1899-12-30")
```

# Lubridate

## Lubridate
 
- Lubridate is an R package that makes it easier to work with dates and times.
- Lubridate was created by Garrett Grolemund and Hadley Wickham.

```{r}
# install.packages("lubridate")
library(lubridate)
```
 

## Parse a date
 
- Lubridate accepts lots of formats

```{r}
ymd("20110604")
mdy("06-04-2011")
dmy("04/06/2011")
```
 

## Parse a date and time

```{r}
ymd_hms("2011-06-04 12:00:00", tz = "Pacific/Auckland")
```
 

## Extraction

```{r}
arrive <- ymd_hms("2011-06-04 12:00:00")
second(arrive)
second(arrive) <- 25
arrive
```
 

## Intervals

```{r}
arrive <- ymd_hms("2011-06-04 12:00:00")
leave <- ymd_hms("2011-08-10 14:00:00")
interval(arrive, leave)
```
 

## Arithmetic

```{r}
mydate <- ymd("20130130")
mydate + days(2)
mydate + months(5)
```
 

## Arithmetic
```{r}
mydate <- ymd("20130130")
mydate + days(1:5)
```
 

## End of (next) month

```{r}
jan31 <- ymd("2013-01-31")
jan31 + months(1)
ceiling_date(jan31, "month") - days(1)
floor_date(jan31, "month") + months(2) - days(1)
```

# Plotting in R

## Motivation
\begin{center}
\Large One skill that isn't taught in grad school is how to make a nice chart. \\
\vspace{5mm}
\normalsize - Managing Director at Citigroup
\end{center}

## What makes a chart nice?
- The reader should look at the chart and immediately understand what data are displayed.
- This means we need:
    - A clear title.
    - Clear labels for each axis (scale and units).
    - A legend if more than one time series is displayed.
    - Different colors and line formats for different time series.
    - Grid lines.
    - Labels.

## Plotting Facilities in R
- R has excellent plotting methods built-in.
- I will focus on base R.
- As a next step, I recommend learning `ggplot2`, an excellent plotting package.
- http://www.r-graph-gallery.com/

## Basic Plotting
 
- `example(plot)`
- `example(hist)`
- `?par`
- `?plot.default`

## The `plot()` Function
- `plot()` is generic function, i.e. a placeholder for a family of functions.
    - the function that is actually called depends on the class of the object on which it is called.
- `plot()` works in stages.
    - you can build up a graph in stages by issuing a series of commands.
- We will see how this works with an example.


## A Basic Plot
```{r, fig.height=5}
x <- seq(1:12)
y <- c(69, 68.7, 70.7, 73.2, 74.9, 78.2,
       82.6, 84.4, 83.5, 79, 73.6, 67.8)
plot(x, y)
```

## `xlim()` and `ylim()`

## Graphical **`par`**amaters
- Graphical parameters can be set as arguments to the `par` function, or they can be passed to the `plot` function.
- Make sure to read through `?par`.
- Some useful parameters:
    - `cex`: sizing of text and symbols
    - `pch`: point type.
    - `lty`: line type.
        - 0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash
    - `lwd`: line width.
    - `mar`: margins.

## `pch`
- `pch` sets how points are displayed

\centerline{
  \includegraphics[width=\textwidth,keepaspectratio]{./graphics/pch.png}
}
```{r, fig.height = 5}
plot(x,y, pch = 16, col='darkblue')
```

## Colors in R
- `colors()` returns all available color names.
- `rainbow(n)`, `heat.colors(n)`, `terrain.colors(n)` and `cm.colors(n)` return a vector of `n` contiguous colors.
```{r, fig.height = 5}
plot(x, y, pch = 21, col=heat.colors(12),
     cex = 2, bg = rev(heat.colors(12)))
```

## `lines()`
- `lines()` takes coordinates and joins the corresponding points with line segments.
    - Notice, by calling `lines` after `plot` the line is on top of the points.
    - This is why we want to build the plot in stages.
```{r, fig.height = 4}
plot(x,y, pch = 16, col='darkblue', cex=2)
lines(x, y, col='darkgrey', lwd = 3)
```

## `points()`
- `points` is a generic function to draw a sequence of points at the specified coordinates. The specified character(s) are plotted, centered at the coordinates.
```{r, fig.height = 4}
plot(x,y, pch = 16, col='darkblue', cex=2)
lines(x, y, col='darkgrey', lwd = 3)
points(x, y, col=rainbow(12), pch=1:12, cex=3, lwd=2)
```

## `grid()`
- `grid` adds a rectangular grid to an existing plot.
- `?grid` for more details.
```{r, fig.height = 4}
plot(x,y, pch = 16, col='darkblue', cex=2)
lines(x, y, col='darkgrey', lwd = 3)
points(x, y, col=rainbow(12), pch=1:12, cex=3, lwd=2)
grid(col="blue", lwd=2)
```

## `abline()`
- `abline` adds one or more straight lines through the current plot.
```{r, fig.height = 4}
x2 <- 1:10; y2 <- 1 + 2*x2 + rnorm(10)
plot(x2,y2, pch = 16, col='darkblue')
model <- lm(y2 ~ x2)
abline(model, col="darkgrey", lwd=2)
abline(v = 5, col = "red", lty = 2)
```

## Adding a Title in Lables
- Use the `main` argument for a title.
- Use the `xlab` and `ylab` for axis labels.
```{r, fig.height = 5}
plot(x,y, pch = 16, col='darkblue',
     xlab = "Month", ylab = "Temperature (degrees F)",
     main = "Average High Temperature in Los Angeles, CA")
```

## Adding a Legend: The `legend()` Function
- see `?legend` and `example(legend)`
```{r, fig.height = 5}
plot(x,y, pch = 16, col='darkblue')
legend("topleft", inset=.01, "Average High Temperature",
  col = "darkblue", pch = 16, bg="white",box.col="white")
```

## `text()` and `locator()`
- Use the `text()` function to add text anywhere in the current graph.
- `locator()` allows you to click on a point in the chart and returns the location.
```{r, fig.height = 4}
plot(x,y, pch = 16, col='darkblue')
text(2,75, "ABC")
```

## `curve()`
- With `curve()`, you can plot a function.
```{r, fig.height = 5}
curve(cos(x), -2*pi, 2*pi)
```


## Saving a Plot to a File
1. Open a file: `pdf("name.pdf")`
2. Create the plot.
3. Close the device with `dev.off()`

- You can use `dev.copy()` to save the displayed graph.
- See `library(help = "grDevices")` for more information.

## An Example of Plotting in R
- Let's plot the cumulative (gross) return of IBM and the S\&P 500 since 1980.
```{r,message=FALSE}
library(quantmod)
getSymbols(c("^GSPC", "IBM"),from = "1979-12-31")
adj_close <- merge(GSPC$GSPC.Adjusted, IBM$IBM.Adjusted)
daily_returns <- diff(adj_close)/lag(adj_close)
cum_ret <- cumprod(1+daily_returns[-1,])
ret1 <- xts(matrix(1, ncol=2), as.Date("1979-12-31"))
cum_ret <- (rbind(cum_ret, ret1) - 1)*100
colnames(cum_ret) <- c("GSPC", "IBM")
```


## The Data
```{r}
head(cum_ret, 9)
```

## Start with a Blank Chart and Build it Up
```{r, eval=FALSE}
plot(cum_ret$IBM, xlab="", ylab = "Cumulative Net Return (Percent)",
     main="", major.ticks="years", minor.ticks=F,
     type="n", major.format = "%Y", auto.grid=F,
     ylim = c(-500, 3000))
abline(h=seq(-500,3000,500), col="darkgrey", lty=2)
lines(cum_ret$GSPC, col="black", lwd=2)
lines(cum_ret$IBM, col="blue", lwd=2)
legend("topleft", inset=.02, 
       c("IBM","GSPC"), col=c("blue", "black"),
       lwd=c(2,2),bg="white", box.col="white")
```

## The Chart
```{r, echo=FALSE}
plot(cum_ret$IBM, xlab="",
     ylab = "Cumulative Net Return (Percent)",
     main="", major.ticks="years", minor.ticks=F,
     type="n", major.format = "%Y", auto.grid=F,
     ylim = c(-100, 3000))
title(main = "Cumulative Net Return of IBM and GSPC")
abline(h=seq(0,3000,500), col="darkgrey", lty=2)
lines(cum_ret$GSPC, col="black", lwd=2)
lines(cum_ret$IBM, col="blue", lwd=2)
legend("topleft", inset=.02, 
       c("IBM","S&P500"), col=c("blue", "black"),
       lwd=c(2,2),bg="white", box.col="white", cex = 1.25)
```

## Lab 2
\begin{center}
\Large Let's work on Lab 2.
\end{center}